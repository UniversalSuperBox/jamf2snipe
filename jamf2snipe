#!/bin/python3
"""
jamf2snipe - Inventory Import

ABOUT:
    This program is designed to import inventory information from a
    JAMFPro into snipe-it using api calls. For more information
    about both of these products, please visit their respecitive
    websites:
        https://jamf.com
        https://snipeitapp.com

LICENSE:
    GLPv3

CONFIGURATION:
    These settings are commonly found in the settings.conf file.

    This setting sets the Snipe Asset status when creating a new asset. By default it's set to 4 (Pending).
    defaultStatus = 4

    You can associate snipe hardware keys in the [api-mapping] section, to to a JAMF keys so it associates
    the jamf values into snipe. The default example associates information that exists by default in both
    Snipe and JAMF.  The Key value is the exact name of the snipe key name.
    Value1 is the "Subset" (JAMF's wording not mine) name, and the Value2 is the JAMF key name.
    Note that MAC Address are a custom value in SNIPE by default and you can use it as an example.

    [api-mapping]
        name = general name
        _snipeit_mac_address_1 = general mac_address
        _snipeit_custom_name_1234567890 = subset jamf_key

    A list of valid subsets can be found in the 'validsubset' variable
"""
validsubset = [
        "general",
        "location",
        "purchasing",
        "peripherals",
        "hardware",
        "certificates",
        "software",
        "extension_attributes",
        "groups_accounts",
        "iphones",
        "configuration_profiles"
]


import argparse
import configparser
import logging
import sys
import time

import requests

# Set us up for using runtime arguments by defining them.
runtimeargs = argparse.ArgumentParser()
runtimeargs.add_argument("-v", "--verbose", help="Sets the logging level to INFO and gives you a better idea of what the script is doing.", action="store_true")
runtimeargs.add_argument("--dryrun", help="This checks your config and tries to contact both the JAMFPro and Snipe-it instances, but exits before updating or syncing any assets.", action="store_true")
runtimeargs.add_argument("-d", "--debug", help="Sets logging to include additional DEBUG messages.", action="store_true")
runtimeargs.add_argument("--do_not_update_jamf", help="Does not update Jamf with the asset tags stored in Snipe.", action="store_false")
runtimeargs.add_argument('--do_not_verify_ssl', help="Skips SSL verification for all requests. Helpful when you use self-signed certificate.", action="store_true")
runtimeargs.add_argument("-r", "--ratelimited", help="Puts a half second delay between Snipe IT API calls to adhere to the standard 120/minute rate limit", action="store_true")
runtimeargs.add_argument("-f", "--force", help="Updates the Snipe asset with information from Jamf every time, despite what the timestamps indicate.", action="store_true")
user_opts = runtimeargs.add_mutually_exclusive_group()
user_opts.add_argument("-u", "--users", help="Checks out the item to the current user in Jamf if it's not already deployed", action="store_true")
user_opts.add_argument("-ui", "--users_inverse", help="Checks out the item to the current user in Jamf if it's already deployed", action="store_true")
user_opts.add_argument("-uf", "--users_force", help="Checks out the item to the user specified in Jamf no matter what", action="store_true")
user_opts.add_argument("-uns", "--users_no_search", help="Doesn't search for any users if the specified fields in Jamf and Snipe don't match. (case insensitive)", action="store_true")
type_opts = runtimeargs.add_mutually_exclusive_group()
type_opts.add_argument("-m", "--mobiles", help="Runs against the Jamf mobiles endpoint only.", action="store_true")
type_opts.add_argument("-c", "--computers", help="Runs against the Jamf computers endpoint only.", action="store_true")
USER_ARGS = runtimeargs.parse_args()

# Notify users they're going to get a wall of text in verbose mode.
if USER_ARGS.verbose:
    logging.basicConfig(level=logging.INFO)
elif USER_ARGS.debug:
    logging.basicConfig(level=logging.DEBUG)
else:
    logging.basicConfig(level=logging.WARNING)

# Notify users if we're doing a dry run.
if USER_ARGS.dryrun:
    print("Dryrun: Starting jamf2snipe with a dry run where no assets will be updated.")

# Find a valid settings.conf file.
logging.info("Searching for a valid settings.conf file.")
config = configparser.ConfigParser()
logging.debug("Checking for a settings.conf in /opt/jamf2snipe ...")
config.read("/opt/jamf2snipe/settings.conf")
if 'snipe-it' not in set(config):
    logging.debug("No valid config found in: /opt Checking for a settings.conf in /etc/jamf2snipe ...")
    config.read('/etc/jamf2snipe/settings.conf')
if 'snipe-it' not in set(config):
    logging.debug("No valid config found in /etc Checking for a settings.conf in current directory ...")
    config.read("settings.conf")
if 'snipe-it' not in set(config):
    logging.debug("No valid config found in current folder.")
    logging.error("No valid settings.conf was found. We'll need to quit while you figure out where the settings are at. You can check the README for valid locations.")
    raise SystemExit("Error: No valid settings.conf - Exiting.")

logging.info("Great, we found a settings file. Let's get started by parsing all fo the settings.")

# Set some Variables from the settings.conf:
# This is the address, cname, or FQDN for your JamfPro instance.
JAMF_BASE = config['jamf']['url']
logging.info("The configured JAMFPro base url is: %s", JAMF_BASE)
JAMF_API_USER = config['jamf']['username']
logging.info("The configured JAMFPro username we'll be connecting with is: %s", JAMF_API_USER)
JAMF_API_PASSWORD = config['jamf']['password']
logging.debug("The configured password to access the API is: %s", JAMF_API_PASSWORD)

# This is the address, cname, or FQDN for your snipe-it instance.
SNIPE_BASE = config['snipe-it']['url']
logging.info("The configured Snipe-IT base url is: %s", SNIPE_BASE)
apiKey = config['snipe-it']['apiKey']
logging.debug("The API key you provided for Snipe is: %s", apiKey)
defaultStatus = config['snipe-it']['defaultStatus']
logging.info("The default status we'll be setting updated computer to is: %s (I sure hope this is a number or something is probably wrong)", defaultStatus)

#TODO: Fail if defaultStatus is not an integer, assuming Snipe-IT can't accept anything but integer statuses.

# Headers for the API call.

logging.info("Creating the headers we'll need for API calls")
JAMF_HEADERS = {'Accept': 'application/json'}
SNIPE_HEADERS = {'Authorization': 'Bearer {}'.format(apiKey), 'Accept': 'application/json', 'Content-Type':'application/json'}
logging.debug('Request headers for JamfPro will be: %s\nRequest headers for Snipe will be: %s', JAMF_HEADERS, SNIPE_HEADERS)

# Check the config file for correct headers

# Do some tests to see if the user has updated their settings.conf file
SETTINGS_CORRECT = True
if 'api-mapping' in config:
    logging.error("Looks like you're using the old method for api-mapping. Please use computers-api-mapping and mobile_devices-api-mapping.")
    SETTINGS_CORRECT = False
if 'user-mapping' not in config and (USER_ARGS.users or USER_ARGS.users_force or USER_ARGS.users_inverse):
    logging.error("""You've chosen to check out assets to users in some capacity using a cmdline switch, but not specified how you want to
    search Snipe IT for the users from Jamf. Make sure you have a 'user-mapping' section in your settings.conf file.""")
    SETTINGS_CORRECT = False

if not SETTINGS_CORRECT:
    raise SystemExit

# Check the config file for valid jamf subsets. This is based off the JAMF API and if it's not right we can't map fields over to SNIPE properly.
logging.debug("Checking the settings.conf file for valid JAMF subsets of the JAMF API so mapping can occur properly.")
for key in config['computers-api-mapping']:
    jamfsplit = config['computers-api-mapping'][key].split()
    if jamfsplit[0] in validsubset:
        logging.info('Found subset %s: Acceptable', jamfsplit[0])
        continue
    else:
        logging.error("Found invalid subset: %s in the settings.conf file.\nThis is not in the acceptable list of subsets. Check your settings.conf\n Valid subsets are: %s", jamfsplit[0], ', '.join(validsubset))
        raise SystemExit("Invalid Subset found in settings.conf")

### Setup Some Functions ###
SNIPE_API_COUNT = 0
FIRST_SNIPE_CALL = None
RATE_LIMIT_SNIPE = USER_ARGS.ratelimited

def snipe_request_handler(r, *args, **kwargs): #pylint: disable=unused-argument,invalid-name
    """Handles rate limiting for the Snipe-IT server.

    This function should be passed as a response hook on every request made to
    the Snipe-IT server. The easiest way to ensure this happens is to use the
    requests.Session made for Snipe-IT requests.
    """
    global SNIPE_API_COUNT
    global FIRST_SNIPE_CALL
    global SNIPE_SESSION
    if RATE_LIMIT_SNIPE:
        if '"messages":429' in r.text:
            logging.warning("Despite respecting the rate limit of Snipe, we've still been limited. Trying again after sleeping for 2 seconds.")
            time.sleep(2)
            re_req = r.request
            return SNIPE_SESSION.send(re_req)
        if SNIPE_API_COUNT == 0:
            FIRST_SNIPE_CALL = time.time()
            time.sleep(0.5)
        SNIPE_API_COUNT += 1
        time_elapsed = (time.time() - FIRST_SNIPE_CALL)
        snipe_api_rate = SNIPE_API_COUNT / time_elapsed
        if snipe_api_rate > 1.95:
            sleep_time = 0.5 + (snipe_api_rate - 1.95)
            logging.debug('Going over snipe rate limit of 120/minute (%s/minute), sleeping for %s', snipe_api_rate, sleep_time)
            time.sleep(sleep_time)
        logging.debug("Made %s requests to Snipe IT in %s seconds, with a request being sent every %s seconds", SNIPE_API_COUNT, time_elapsed, snipe_api_rate)
    if '"messages":429' in r.text:
        logging.error(r.content)
        raise SystemExit("We've been rate limited. Use option -r to respect the built in Snipe IT API rate limit of 120/minute.")
    return r

def jamf_request_handler(r, *args, **kwargs): #pylint: disable=unused-argument,invalid-name
    """Handles rate limiting for the JAMF server.

    This function should be passed as a response hook on every request made to
    the JAMF server. The easiest way to ensure this happens is to use the
    requests.Session made for JAMF requests.
    """
    if r.status_code != 200 and b'policies.ratelimit.QuotaViolation' in r.content:
        # This case should only occur with JAMF's developer portal
        logging.warning('JAMFPro Ratelimit exceeded - error code %s. Pausing for 75 seconds.', r.status_code)
        time.sleep(75)
        logging.info("Finished waiting. Retrying lookup...")
        newresponse = JAMF_SESSION.send(r.request)
        return newresponse
    return r

def session_setup(service, verify_ssl=True):
    """Returns a requests.Session object set up for making requests to a service

    :param service:
        "snipe" or "jamf", determines whether the session is set up for
        querying Snipe-IT or JAMF, respectively.

    :param verify_ssl:
        Whether the created session should verify SSL/TLS certificates or not.
        See https://requests.readthedocs.io/en/master/api/#requests.Session.verify
    """
    session = requests.Session()
    if service == "snipe":
        session.hooks["response"].append(snipe_request_handler)
    elif service == "jamf":
        session.hooks["response"].append(jamf_request_handler)
    else:
        raise ValueError("Incorrect service specified")
    session.verify = verify_ssl
    return session

def get_jamf_computers(session=None):
    """Retrieves a list of all computers from the JAMF instance.

    The JAMF instance is specified by the global variable ``JAMF_BASE``

    :param session:
        requests.Session object to use for this request. If none is provided,
        one will be created for you.
    """
    if session is None:
        session = session_setup("jamf")
    api_url = '{0}/JSSResource/computers'.format(JAMF_BASE)
    logging.debug('Calling for JAMF computers against: %s\n The username, passwords, and headers for this GET requestcan be found near the beginning of the output.', api_url)
    response = session.get(api_url, auth=(JAMF_API_USER, JAMF_API_PASSWORD), headers=JAMF_HEADERS)
    if response.status_code == 200:
        logging.debug("Got back a valid 200 response code.")
        return response.json()
    logging.warning('Received an invalid status code when trying to retreive JAMF Device list:%s - %s', response.status_code, response.content)
    logging.debug("Returning a null value for the function.")
    return None

def get_jamf_mobiles(session=None):
    """Retrieves a list of all mobile devices from the JAMF instance.

    The JAMF instance is specified by the global variable ``JAMF_BASE``

    :param session:
        requests.Session object to use for this request. If none is provided,
        one will be created for you.
        provided.
    """
    if session is None:
        session = session_setup("jamf")
    api_url = '{0}/JSSResource/mobiledevices'.format(JAMF_BASE)
    logging.debug('Calling for JAMF mobiles against: %s\n The username, passwords, and headers for this GET requestcan be found near the beginning of the output.', api_url)
    response = session.get(api_url, auth=(JAMF_API_USER, JAMF_API_PASSWORD), headers=JAMF_HEADERS)
    if response.status_code == 200:
        logging.debug("Got back a valid 200 response code.")
        return response.json()
    logging.warning('Received an invalid status code when trying to retreive JAMF Device list:%s - %s', response.status_code, response.content)
    logging.debug("Returning a null value for the function.")
    return None

def search_jamf_asset(jamf_id, session=None):
    """Retrieves a single computer from the JAMF instance by ID.

    The JAMF instance is specified by the global variable ``JAMF_BASE``

    :param jamf_id: JAMF instance's unique ID value identifying this computer.

    :param session:
        requests.Session object to use for this request. If none is provided,
        one will be created for you.
    """
    if session is None:
        session = session_setup("jamf")
    api_url = "{}/JSSResource/computers/id/{}".format(JAMF_BASE, jamf_id)
    response = session.get(api_url, auth=(JAMF_API_USER, JAMF_API_PASSWORD), headers=JAMF_HEADERS)
    if response.status_code == 200:
        logging.debug("Got back a valid 200 response code.")
        jsonresponse = response.json()
        logging.debug("Returning: %s", jsonresponse['computer'])
        return jsonresponse['computer']
    logging.warning('JAMFPro responded with error code:%s when we tried to look up id: %s', response, jamf_id)
    logging.debug("Returning a null value for the function.")
    return None

def search_jamf_mobile(jamf_id, session=None):
    """Retrieves a single mobile device from the JAMF instance by ID.

    The JAMF instance is specified by the global variable ``JAMF_BASE``

    :param jamf_id: JAMF instance's unique ID value identifying this mobile
        device.

    :param session:
        requests.Session object to use for this request. If none is provided,
        one will be created for you.
    """
    if session is None:
        session = session_setup("jamf")
    api_url = "{}/JSSResource/mobiledevices/id/{}".format(JAMF_BASE, jamf_id)
    response = session.get(api_url, auth=(JAMF_API_USER, JAMF_API_PASSWORD), headers=JAMF_HEADERS)
    if response.status_code == 200:
        logging.debug("Got back a valid 200 response code.")
        jsonresponse = response.json()
        logging.debug("Returning: %s", jsonresponse['mobile_device'])
        return jsonresponse['mobile_device']
    logging.warning('JAMFPro responded with error code:%s when we tried to look up id: %s', response, jamf_id)
    logging.debug("Returning a null value for the function.")
    return None

def update_jamf_asset_tag(jamf_id, asset_tag, session=None):
    """Updates the asset tag field on a single computer in JAMF.

    The JAMF instance is specified by the global variable ``JAMF_BASE``

    :param jamf_id: JAMF instance's unique ID value identifying this computer.

    :param asset_tag: The new value for the asset tag field for this computer
        in the JAMF instance.

    :param session:
        requests.Session object to use for this request. If none is provided,
        one will be created for you.
    """
    if session is None:
        session = session_setup("jamf")
    api_url = "{}/JSSResource/computers/id/{}".format(JAMF_BASE, jamf_id)
    payload = """<?xml version="1.0" encoding="UTF-8"?><computer><general><id>{}</id><asset_tag>{}</asset_tag></general></computer>""".format(jamf_id, asset_tag)
    logging.debug('Making Get request against: %s\nPayload for the PUT request is: %s\nThe username, password, and headers can be found near the beginning of the output.', api_url, payload)
    response = session.put(api_url, auth=(JAMF_API_USER, JAMF_API_PASSWORD), data=payload, headers=JAMF_HEADERS)
    if response.status_code == 201:
        logging.debug("Got a 201 response. Returning: True")
        return True
    if response.status_code == 200:
        logging.debug("Got a 200 response code. Returning the response: %s", response)
        return response.json()
    logging.warning('Got back an error response code:%s - %s', response.status_code, response.content)
    return None

def update_jamf_mobiledevice_asset_tag(jamf_id, asset_tag, session=None):
    """Updates the asset tag field on a single mobile device in JAMF.

    The JAMF instance is specified by the global variable ``JAMF_BASE``

    :param jamf_id: JAMF instance's unique ID value identifying this mobile
        device.

    :param asset_tag: The new value for the asset tag field for this mobile
        device in the JAMF instance.

    :param session:
        requests.Session object to use for this request. If none is provided,
        one will be created for you.
    """
    if session is None:
        session = session_setup("jamf")
    api_url = "{}/JSSResource/mobiledevices/id/{}".format(JAMF_BASE, jamf_id)
    payload = """<?xml version="1.0" encoding="UTF-8"?><mobile_device><general><id>{}</id><asset_tag>{}</asset_tag></general></mobile_device>""".format(jamf_id, asset_tag)
    logging.debug('Making Get request against: %s\nPayload for the PUT request is: %s\nThe username, password, and headers can be found near the beginning of the output.', api_url, payload)
    response = session.put(api_url, auth=(JAMF_API_USER, JAMF_API_PASSWORD), data=payload, headers=JAMF_HEADERS)
    if response.status_code == 201:
        logging.debug("Got a 201 response. Returning: True")
        return True
    if response.status_code == 200:
        logging.debug("Got a 200 response code. Returning the response: %s", response)
        return response.json()
    logging.warning('Got back an error response code:%s - %s', response.status_code, response.content)
    return None

def search_snipe_asset(serial, session=None):
    """Looks up an asset by its serial number in Snipe-IT.

    The Snipe-IT instance is specified by the ``SNIPE_BASE`` global variable.

    Snipe-IT does not enforce uniqueness of the serial number, so it may return
    more than one asset for the search.

    :returns: If a single match is found, a dict object representing the match
        is returned.

        If no match is found, the string ``"NoMatch"`` is returned.

        If more than one match is found, the string ``"MultiMatch"`` is
        returned.

        If any error occurs during the request, the string ``"ERROR"`` is
        returned.

    :param serial: Serial number to look up in Snipe-IT.

    :param session:
        requests.Session object to use for this request. If none is provided,
        one will be created for you.
    """
    if session is None:
        session = session_setup("snipe")
    api_url = '{}/api/v1/hardware/byserial/{}'.format(SNIPE_BASE, serial)
    response = session.get(api_url, headers=SNIPE_HEADERS)
    if response.status_code == 200:
        jsonresponse = response.json()
        # Check to make sure there's actually a result
        if jsonresponse['total'] == 1:
            return jsonresponse
        elif jsonresponse['total'] == 0:
            logging.info("No assets match %s", serial)
            return "NoMatch"
        else:
            logging.warning('FOUND %s matching assets while searching for: %s', jsonresponse['total'], serial)
            return "MultiMatch"
    else:
        logging.warning('Snipe-IT responded with error code:%s when we tried to look up: %s', response.text, serial)
        logging.debug('%s - %s', response.status_code, response.content)
        return "ERROR"

def get_snipe_models(session=None):
    """Looks up all of the asset models in Snipe-IT.

    The Snipe-IT instance is specified by the ``SNIPE_BASE`` global variable.

    Returns a dict object matching https://snipe-it.readme.io/reference#models

    Exits the program on errors.

    :param session:
        requests.Session object to use for this request. If none is provided,
        one will be created for you.
    """
    if session is None:
        session = session_setup("snipe")
    api_url = '{}/api/v1/models'.format(SNIPE_BASE)
    logging.debug('Calling against: %s', api_url)
    response = session.get(api_url, headers=SNIPE_HEADERS)
    if response.status_code == 200:
        jsonresponse = response.json()
        logging.info("Got a valid response that should have %s models.", jsonresponse['total'])
        if jsonresponse['total'] <= len(jsonresponse['rows']):
            return jsonresponse
        else:
            logging.info("We didn't get enough results so we need to get them again.")
            api_url = '{}/api/v1/models?limit={}'.format(SNIPE_BASE, jsonresponse['total'])
            newresponse = session.get(api_url, headers=SNIPE_HEADERS)
            if response.status_code == 200:
                newjsonresponse = newresponse.json()
                if newjsonresponse['total'] == len(newjsonresponse['rows']):
                    return newjsonresponse
                else:
                    logging.error("We couldn't seem to get all of the model numbers")
                    raise SystemExit("Unable to get all model objects from Snipe-IT instanace")
            else:
                logging.error('When we tried to retreive a list of models, Snipe-IT responded with error status code:%s - %s', response.status_code, response.content)
                raise SystemExit("Snipe models API endpoint failed.")
    else:
        logging.error('When we tried to retreive a list of models, Snipe-IT responded with error status code:%s - %s', response.status_code, response.content)
        raise SystemExit("Snipe models API endpoint failed.")

def get_snipe_users(previous=None, session=None):
    """Get a list of all users in Snipe-IT.

    The Snipe-IT instance is specified by the ``SNIPE_BASE`` global variable.

    This function is recursive. Please call it without the ``previous``
    argument, it will eventually return your list.

    :param previous: List of users to append to in this run.

    :param session:
        requests.Session object to use for this request. If none is provided,
        one will be created for you.
    """
    if previous is None:
        previous = []
    if session is None:
        session = session_setup("snipe")
    user_id_url = '{}/api/v1/users'.format(SNIPE_BASE)
    payload = {
        'limit': 100,
        'offset': len(previous)
    }
    logging.debug('The payload for the snipe users GET is %s', payload)
    response = session.get(user_id_url, headers=SNIPE_HEADERS, json=payload)
    response_json = response.json()
    current = response_json['rows']
    if len(previous) != 0:
        current = previous + current
    if response_json['total'] > len(current):
        logging.debug('We have more than 100 users, get the next page - total: %s current: %s', response_json['total'], len(current))
        return get_snipe_users(previous=current, session=session)
    return current

def get_snipe_user_id(username, user_list, do_not_search, session=None):
    """Get a Snipe-IT user's unique identifier given their username.

    The Snipe-IT instance is specified by the ``SNIPE_BASE`` global variable.

    :param username: Username to search Snipe-IT for.

    :param user_list: A list of users returned by get_snipe_users.

    :param do_not_search:
        Do not try to use the Snipe-IT user search to find the requested
        username if we were completely unable to find them in user_dict.

    :param session:
        requests.Session object to use for this request. If none is provided,
        one will be created for you.

    :returns: ``"id"`` value of the user object from Snipe-IT.
    """
    if session is None:
        session = session_setup("snipe")
    if username == '':
        return "NotFound"
    username = username.lower()
    for user in user_list:
        for value in user.values():
            if str(value).lower() == username:
                user_id = user['id']
                return user_id
    if do_not_search:
        logging.debug("No matches in SNIPE_USERS for %s, not querying the API for the next closest match since we've been told not to", username)
        return "NotFound"
    logging.debug('No matches in SNIPE_USERS for %s, querying the API for the next closest match', username)
    user_id_url = '{}/api/v1/users'.format(SNIPE_BASE)
    payload = {
        'search':username,
        'limit':1,
        'sort':'username',
        'order':'asc'
    }
    logging.debug('The payload for the snipe user search is: %s', payload)
    response = session.get(user_id_url, headers=SNIPE_HEADERS, json=payload)
    try:
        return response.json()['rows'][0]['id']
    except (KeyError, IndexError):
        return "NotFound"

def create_snipe_model(payload, session=None):
    """Creates a new model in Snipe-IT.

    The Snipe-IT instance is specified by the ``SNIPE_BASE`` global variable.

    :param payload: JSON to send directly to the models endpoint in Snipe-IT.

    :param session:
        requests.Session object to use for this request. If none is provided,
        one will be created for you.

    :returns: The new model's unique identifier (id) value in Snipe-IT.

    :raises ValueError: Snipe-IT returned a status code other than 200 OK.
    """
    if session is None:
        session = session_setup("snipe")
    api_url = '{}/api/v1/models'.format(SNIPE_BASE)
    logging.debug('Calling to create new snipe model type against: %s\nThe payload for the POST request is:%s\nThe request headers can be found near the start of the output.', api_url, payload)
    response = session.post(api_url, headers=SNIPE_HEADERS, json=payload)
    if response.status_code == 200:
        return response.json()['payload']['id']
    raise ValueError("Received error code {} when trying to create a new asset model in Snipe-IT. The response content is:\n{}".format(response.status_code, response.text))

def create_snipe_asset(payload, session=None):
    """Creates a new asset in Snipe-IT.

    The Snipe-IT instance is specified by the ``SNIPE_BASE`` global variable.

    :param payload: JSON to send directly to the models endpoint in Snipe-IT.

    :param session:
        requests.Session object to use for this request. If none is provided,
        one will be created for you.

    :returns:
        A tuple of the format ``(status, response)`` where ``status`` is the
        string ``"AssetCreated"`` and ``response`` is the requests.Response
        object returned for the requst.
    """
    if session is None:
        session = session_setup("snipe")
    api_url = '{}/api/v1/hardware'.format(SNIPE_BASE)
    logging.debug('Calling to create a new asset against: %s\nThe payload for the POST request is:%s\nThe request headers can be found near the start of the output.', api_url, payload)
    response = session.post(api_url, headers=SNIPE_HEADERS, json=payload)
    logging.debug(response.text)
    if response.status_code == 200:
        logging.debug("Got back status code: 200 - %s", response.content)
        return 'AssetCreated', response
    else:
        logging.error('Asset creation failed for asset %s with error %s', payload['name'], response.text)
        return response

def update_snipe_asset(snipe_id, payload, session=None):
    """Updates an existing asset in Snipe-IT.

    The Snipe-IT instance is specified by the ``SNIPE_BASE`` global variable.

    :param snipe_id: Unique identifier of the object to update in Snipe-IT.

    :param payload: JSON to send directly to the models endpoint in Snipe-IT.

    :param session:
        requests.Session object to use for this request. If none is provided,
        one will be created for you.

    :returns: True if the update was successful, False if it was not.
    """
    if session is None:
        session = session_setup("snipe")
    api_url = '{}/api/v1/hardware/{}'.format(SNIPE_BASE, snipe_id)
    logging.debug('The payload for the snipe update is: %s', payload)
    response = session.patch(api_url, headers=SNIPE_HEADERS, json=payload)
    # Verify that the payload updated properly.
    goodupdate = True
    if response.status_code == 200:
        logging.debug("Got back status code: 200 - Checking the payload updated properly: If you error here it's because you configure the API mapping right.")
        jsonresponse = response.json()
        for key in payload:
            if jsonresponse['payload'][key] != payload[key]:
                logging.error('Unable to update ID: %s. We failed to update the %s field with "%s"', snipe_id, key, payload[key])
                goodupdate = False
            else:
                logging.info("Sucessfully updated %s with: %s", key, payload[key])
        return goodupdate
    else:
        logging.warning('Whoops. Got an error status code while updating ID %s: %s - %s', snipe_id, response.status_code, response.content)
        return False

def checkin_snipe_asset(asset_id, session=None):
    """Checks in a single asset in Snipe-IT, removing its assignee.

    The Snipe-IT instance is specified by the ``SNIPE_BASE`` global variable.

    :param asset_id: Unique identifier of the object to update in Snipe-IT.

    :param session:
        requests.Session object to use for this request. If none is provided,
        one will be created for you.

    :returns:
        The string ``"CheckedOut"`` if the checkin was successful, the
        ``requests.Response`` object returned by the request if the checkin was
        not successful.
    """
    if session is None:
        session = session_setup("snipe")
    api_url = '{}/api/v1/hardware/{}/checkin'.format(SNIPE_BASE, asset_id)
    payload = {
        'note':'checked in by script from Jamf'
    }
    logging.debug('The payload for the snipe checkin is: %s', payload)
    response = session.post(api_url, headers=SNIPE_HEADERS, json=payload)
    logging.debug('The response from Snipe IT is: %s', response.json())
    if response.status_code == 200:
        logging.debug("Got back status code: 200 - %s", response.content)
        return "CheckedOut"
    return response

def checkout_snipe_asset(user, asset_id, user_list, do_not_search, checked_out_user=None, session=None):
    """Checks out a single asset in Snipe-IT to the specified user.

    The Snipe-IT instance is specified by the ``SNIPE_BASE`` global variable.

    It is the caller's responsibility to provide the currently checked-out user
    as the ``checked_out_user`` argument.

    :param user: Username of the user to check this asset out to.

    :param asset_id: Unique identifier of the object to update in Snipe-IT.

    :param user_list: A list of users returned by get_snipe_users.

    :param do_not_search:
        Do not try to use the Snipe-IT user search to find the requested
        username if we were completely unable to find them in user_dict.

    :param checked_out_user:
        Unique identifier (``"id"``) of the user which this asset is checked
        out to at call time, or ``"NewAsset"`` if this asset was just created.

    :param session:
        requests.Session object to use for this request. If none is provided,
        one will be created for you.

    :returns:
        ``"NotFound"`` if the user with the given username does not exist.

        ``"CheckedOut"`` if the asset was checked out successfully.

        The ``requests.Response`` object returned by the checkout request if
        it was not successful.
    """
    if session is None:
        session = session_setup("snipe")
    logging.debug('Asset %s is being checked out to %s', user, asset_id)
    user_id = get_snipe_user_id(user, user_list, do_not_search, session=session)
    if user_id == 'NotFound':
        logging.info("User %s not found", user)
        return "NotFound"
    if checked_out_user is None:
        logging.info("Not checked out, checking out to %s", user)
    elif checked_out_user == "NewAsset":
        logging.info("First time this asset will be checked out, checking out to %s", user)
    elif checked_out_user['id'] == user_id:
        logging.info("%s already checked out to user %s", asset_id, user)
        return 'CheckedOut'
    else:
        logging.info("Checking in %s to check it out to %s", asset_id, user)
        checkin_snipe_asset(asset_id, session=session)
    api_url = '{}/api/v1/hardware/{}/checkout'.format(SNIPE_BASE, asset_id)
    logging.info("Checking out %s to check it out to %s", asset_id, user)
    payload = {
        'checkout_to_type':'user',
        'assigned_user':user_id,
        'note':'Assignment made automatically, via script from Jamf.'
    }
    logging.debug('The payload for the snipe checkin is: %s', payload)
    response = session.post(api_url, headers=SNIPE_HEADERS, json=payload)
    logging.debug('The response from Snipe IT is: %s', response.json())
    if response.status_code == 200:
        logging.debug("Got back status code: 200 - %s", response.content)
        return "CheckedOut"
    else:
        logging.error('Asset checkout failed for asset %s with error %s', asset_id, response.text)
        return response

def get_snipe_apple_manufacturer(session):
    """ Returns the integer ID of the "Apple" manufacturer in snipe-it.

    Raises ValueError if the "Apple" manufacturer is not found.

    :param session:
        requests.Session object to use for this request. If none is provided,
        one will be created for you.
    """
    #TODO: Handle pagination of the /manufacturers endpoint
    logging.info("Searching for the manufacturer with the name 'Apple'")
    api_url = '{}/api/v1/manufacturers'.format(SNIPE_BASE)
    response = session.get(api_url, headers=SNIPE_HEADERS,)
    for manufacturer in response.json()["rows"]:
        if manufacturer["name"].casefold() == "apple":
            manufacturer_id = manufacturer["id"]
            logging.info("Found the manufacturer with the name 'Apple', its ID is %i", manufacturer_id)
            return manufacturer_id

    raise ValueError("The Apple manufacturer was not found.")

### Run Testing ###
# Report if we're verifying SSL or not.
logging.info("SSL Verification is set to: %s", not USER_ARGS.do_not_verify_ssl)

# Do some tests to see if the hosts are up.

JAMF_SESSION = session_setup("jamf", verify_ssl=not USER_ARGS.do_not_verify_ssl)
SNIPE_SESSION = session_setup("snipe", verify_ssl=not USER_ARGS.do_not_verify_ssl)

logging.info("Running tests to see if hosts are up.")
try:
    SNIPE_UP = SNIPE_SESSION.get(SNIPE_BASE, hooks={'response': snipe_request_handler}).status_code == 200
except Exception as exception: #pylint: disable=broad-except
    logging.exception(exception)
    SNIPE_UP = False
try:
    JAMF_UP = JAMF_SESSION.get(JAMF_BASE).status_code in (200, 401)
except Exception as exception: #pylint: disable=broad-except
    logging.exception(exception)
    JAMF_UP = False

if not SNIPE_UP:
    logging.error('Snipe-IT looks like it is down from here. \nPlease check your config in the settings.conf file, or your instance.')
else:
    logging.info('We were able to get a good response from your Snipe-IT instance.')
if not JAMF_UP:
    logging.error('JAMFPro looks down from here. \nPlease check the your config in the settings.conf file, or your hosted JAMFPro instance.')
else:
    logging.info('We were able to get a good response from your JAMFPro instance.')

# Exit if you can't contact SNIPE
if not JAMF_UP or not SNIPE_UP:
    raise SystemExit("Error: Host could not be contacted.")

# Test that we can actually connect with the API keys.
##TODO Write some more tests here. ha!

logging.info("Finished running our tests.")

### Get Started ###
# Retrieve the ID of the manufacturer with the name "Apple", either from config
# or from Snipe-IT
apple_manufacturer_id = config['snipe-it'].get('manufacturer_id', None)
if apple_manufacturer_id is None:
    try:
        apple_manufacturer_id = get_snipe_apple_manufacturer(SNIPE_SESSION)
    except ValueError:
        #TODO: Make everything else exit this way too.
        logging.critical("Failed to find a manufacturer on your Snipe instance with the name 'Apple' and you did not set one in the configuration file. Make sure the 'Apple' manufacturer exists or set the manufacturer_id in settings.conf.")
        sys.exit(1)
logging.debug("Snipe-IT 'Apple' Manufacturer ID is set to %s", apple_manufacturer_id)

# Get a list of known models from Snipe
logging.info("Getting a list of computer models that snipe knows about.")
snipemodels = get_snipe_models(session=SNIPE_SESSION)
logging.debug("Parsing the %s model results for models with model numbers.", len(snipemodels['rows']))
model_numbers = {}
for model in snipemodels['rows']:
    if model['model_number'] == "":
        logging.debug("The model, %s, did not have a model number. Skipping.", model['name'])
        continue
    model_numbers[model['model_number']] = model['id']
logging.info("Our list of models has %s entries.", len(model_numbers))
logging.debug("Here's the list of the %s models and their id's that we were able to collect:\n%s", len(model_numbers), model_numbers)

# Get the IDS of all active assets.
jamf_computer_list = get_jamf_computers(session=JAMF_SESSION)
jamf_mobile_list = get_jamf_mobiles(session=JAMF_SESSION)
jamf_types = {
    'computers': jamf_computer_list,
    'mobile_devices': jamf_mobile_list
}

# Get a list of users from Snipe if the user has specified
# they're syncing users

if USER_ARGS.users or USER_ARGS.users_force or USER_ARGS.users_inverse:
    SNIPE_USERS = get_snipe_users(session=SNIPE_SESSION)

total_assets = 0
if USER_ARGS.computers:
    total_assets = len(jamf_types['computers']['computers'])
elif USER_ARGS.mobiles:
    total_assets = len(jamf_types['mobile_devices']['mobile_devices'])
else:
    for jamf_type in jamf_types:
        total_assets += len(jamf_types[jamf_type][jamf_type])

# Make sure we have a good list.
if jamf_computer_list is not None:
    logging.info('Received a list of JAMF assets that had %s entries.', total_assets)
else:
    logging.error("We were not able to retreive a list of assets from your JAMF instance. It's likely that your settings, or credentials are incorrect. Check your settings.conf and verify you can make API calls outside of this system with the credentials found in your settings.conf")
    raise SystemExit("Unable to get JAMF Computers.")

# After this point we start editing data, so quit if this is a dryrun
if USER_ARGS.dryrun:
    raise SystemExit("Dryrun: Complete.")

# From this point on, we're editing data.
logging.info('Starting to Update Inventory')
current_asset = 0

for jamf_type in jamf_types:
    if USER_ARGS.computers:
        if jamf_type != 'computers':
            continue
    if USER_ARGS.mobiles:
        if jamf_type != 'mobile_devices':
            continue
    for jamf_asset in jamf_types[jamf_type][jamf_type]:
        current_asset += 1
        logging.info("Processing entry %s out of %s - JAMFID: %s - NAME: %s", current_asset, total_assets, jamf_asset['id'], jamf_asset['name'])
        # Search through the list by ID for all asset information\
        if jamf_type == 'computers':
            jamf = search_jamf_asset(jamf_asset['id'], session=JAMF_SESSION)
        elif jamf_type == 'mobile_devices':
            jamf = search_jamf_mobile(jamf_asset['id'], session=JAMF_SESSION)
        if jamf is None:
            logging.warning("JAMF did not return a device for ID %s for type %s", jamf_asset['id'], jamf_type)
            continue

        # Check that the model number exists in snipe, if not create it.
        if jamf_type == 'computers':
            jamf_model_identifier = jamf['hardware']['model_identifier']
            if jamf_model_identifier not in model_numbers:
                logging.info("Could not find a model ID in snipe for: %s", jamf_model_identifier)
                newmodel = {"category_id":config['snipe-it']['computer_model_category_id'], "manufacturer_id": apple_manufacturer_id, "name": jamf['hardware']['model'], "model_number": jamf_model_identifier}
                if 'computer_custom_fieldset_id' in config['snipe-it']:
                    fieldset_split = config['snipe-it']['computer_custom_fieldset_id']
                    newmodel['fieldset_id'] = fieldset_split
                snipe_model_id = create_snipe_model(newmodel, session=SNIPE_SESSION)
                model_numbers[jamf_model_identifier] = snipe_model_id
        elif jamf_type == 'mobile_devices':
            jamf_model_identifier = jamf['general']['model_identifier']
            if jamf_model_identifier not in model_numbers:
                logging.info("Could not find a model ID in snipe for: %s", jamf_model_identifier)
                newmodel = {"category_id":config['snipe-it']['mobile_model_category_id'], "manufacturer_id": apple_manufacturer_id, "name": jamf['general']['model'], "model_number": jamf_model_identifier}
                if 'mobile_custom_fieldset_id' in config['snipe-it']:
                    fieldset_split = config['snipe-it']['mobile_custom_fieldset_id']
                    newmodel['fieldset_id'] = fieldset_split
                snipe_model_id = create_snipe_model(newmodel, session=SNIPE_SESSION)
                model_numbers[jamf_model_identifier] = snipe_model_id

        # Pass the SN from JAMF to search for a match in Snipe
        snipe = search_snipe_asset(jamf['general']['serial_number'], session=SNIPE_SESSION)

        # Create a new asset if there's no match:
        if snipe == 'NoMatch':
            logging.info("Creating a new asset in snipe for JAMF ID %s - %s", jamf['general']['id'], jamf['general']['name'])
            # This section checks to see if the asset tag was already put into JAMF, if not it creates one with with Jamf's ID.
            if jamf['general']['asset_tag'] == '':
                jamf_asset_tag = None
                logging.debug('No asset tag found in Jamf, checking settings.conf for alternative specified field.')
                if 'asset_tag' in config['snipe-it']:
                    tag_split = config['snipe-it']['asset_tag'].split()
                    try:
                        jamf_asset_tag = jamf[str(tag_split[0])][str(tag_split[1])]
                    except:
                        raise SystemError('No such attribute {} in the jamf payload. Please check your settings.conf file'.format(tag_split))
                if jamf_asset_tag is None or jamf_asset_tag == '':
                    logging.debug('No custom configuration found in settings.conf for asset tag name upon asset creation.')
                    if jamf_type == 'mobile_devices':
                        jamf_asset_tag = 'jamfid-m-{}'.format(jamf['general']['id'])
                    elif jamf_type == 'computers':
                        jamf_asset_tag = 'jamfid-{}'.format(jamf['general']['id'])
            else:
                jamf_asset_tag = jamf['general']['asset_tag']
                logging.info("Asset tag found in Jamf, setting it to: %s", jamf_asset_tag)
            # Create the payload
            if jamf_type == 'mobile_devices':
                logging.debug("Payload is being made for a mobile device")
                newasset = {'asset_tag': jamf_asset_tag, 'model_id': model_numbers[str(jamf['general']['model_identifier'])], 'name': jamf['general']['name'], 'status_id': defaultStatus, 'serial': jamf['general']['serial_number']}
            elif jamf_type == 'computers':
                logging.debug("Payload is being made for a computer")
                newasset = {'asset_tag': jamf_asset_tag, 'model_id': model_numbers[str(jamf['hardware']['model_identifier'])], 'name': jamf['general']['name'], 'status_id': defaultStatus, 'serial': jamf['general']['serial_number']}
            if jamf['general']['serial_number'] == 'Not Available':
                logging.warning("The serial number is not available in JAMF. This is normal for DEP enrolled devices that have not yet checked in for the first time. Since there's no serial number yet, we'll skip it for now.")
                continue
            else:
                new_snipe_asset = create_snipe_asset(newasset, session=SNIPE_SESSION)
                if new_snipe_asset[0] != "AssetCreated":
                    continue
                if USER_ARGS.users or USER_ARGS.users_force or USER_ARGS.users_inverse:
                    jamf_data_category, jamf_data_field = config['user-mapping']['jamf_api_field'].split()
                    if jamf_data_field not in jamf[jamf_data_category]:
                        logging.info("Couldn't find %s for this device in %s, not checking it out.", jamf_data_field, jamf_data_category)
                        continue
                    logging.info('Checking out new item %s to user %s', jamf['general']['name'], jamf[str(jamf_data_category)][str(jamf_data_field)])
                    checkout_snipe_asset(jamf[jamf_data_category][jamf_data_field], new_snipe_asset[1].json()['payload']['id'], SNIPE_USERS, USER_ARGS.users_no_search, "NewAsset", session=SNIPE_SESSION)

        # Log an error if there's an issue, or more than once match.
        elif snipe == 'MultiMatch':
            logging.warning("WARN: You need to resolve multiple assets with the same serial number in your inventory. If you can't find them in your inventory, you might need to purge your deleted records. You can find that in the Snipe Admin settings. Skipping serial number %s for now.", jamf['general']['serial_number'])
        elif snipe == 'ERROR':
            logging.error("We got an error when looking up serial number %s in snipe, which shouldn't happen at this point. Check your snipe instance and setup. Skipping for now.", jamf['general']['serial_number'])

        else:
            # Only update if JAMF has more recent info.
            snipe_id = snipe['rows'][0]['id']
            snipe_time = snipe['rows'][0]['updated_at']['datetime']
            if jamf_type == 'computers':
                jamf_time = jamf['general']['report_date']
            elif jamf_type == 'mobile_devices':
                jamf_time = jamf['general']['last_inventory_update']
            # Check to see that the JAMF record is newer than the previous Snipe update, or if it is a new record in Snipe
            if (jamf_time > snipe_time) or (USER_ARGS.force):
                if USER_ARGS.force:
                    logging.debug("Forced the Update regardless of the timestamps below.")
                logging.debug("Updating the Snipe asset because JAMF has a more recent timestamp: %s > %s or the Snipe Record is new", jamf_time, snipe_time)
                for snipekey in config['{}-api-mapping'.format(jamf_type)]:
                    jamfsplit = config['{}-api-mapping'.format(jamf_type)][snipekey].split()
                    for i, item in enumerate(jamfsplit):
                        try:
                            item = int(item)
                        except ValueError:
                            logging.debug('%s is not an integer', item)
                        if i == 0:
                            jamf_value = jamf[item]
                        else:
                            if jamfsplit[0] == 'extension_attributes':
                                for attribute in jamf_value:
                                    if attribute['id'] == item:
                                        jamf_value = attribute['value']
                            else:
                                jamf_value = jamf_value[item]
                    payload = {snipekey: jamf_value}
                    latestvalue = jamf_value

                    # Need to check that we're not needlessly updating the asset.
                    # If it's a custom value it'll fail the first section and send it to except section that will parse custom sections.
                    try:
                        if snipe['rows'][0][snipekey] != latestvalue:
                            update_snipe_asset(snipe_id, payload, session=SNIPE_SESSION)
                        else:
                            logging.debug("Skipping the payload, because it already exits.")
                    except (KeyError, IndexError):
                        logging.debug("The snipekey lookup failed, which means it's a custom field. Parsing those to see if it needs to be updated or not.")
                        needsupdate = False
                        for CustomField in snipe['rows'][0]['custom_fields']:
                            if snipe['rows'][0]['custom_fields'][CustomField]['field'] == snipekey:
                                if snipe['rows'][0]['custom_fields'][CustomField]['value'] != latestvalue:
                                    logging.debug("Found the field, and the value needs to be updated from %s to %s", snipe['rows'][0]['custom_fields'][CustomField]['value'], latestvalue)
                                    needsupdate = True
                        if needsupdate:
                            update_snipe_asset(snipe_id, payload, session=SNIPE_SESSION)
                        else:
                            logging.debug("Skipping the payload, because it already exists, or the Snipe key we're mapping to doesn't.")
                if ((USER_ARGS.users or USER_ARGS.users_inverse) and (snipe['rows'][0]['assigned_to'] is None) == USER_ARGS.users) or USER_ARGS.users_force:

                    if snipe['rows'][0]['status_label']['status_meta'] in ('deployable', 'deployed'):
                        jamf_data_category, jamf_data_field = config['user-mapping']['jamf_api_field'].split()
                        if jamf_data_field not in jamf[jamf_data_category]:
                            logging.info("Couldn't find %s for this device in %s, not checking it out.", jamf_data_field, jamf_data_category)
                            continue
                        checkout_snipe_asset(jamf[jamf_data_category][jamf_data_field], snipe_id, SNIPE_USERS, USER_ARGS.users_no_search, snipe['rows'][0]['assigned_to'], session=SNIPE_SESSION)
                    else:
                        logging.info("Can't checkout %s since the status isn't set to deployable", jamf['general']['name'])

            else:
                logging.info("Snipe Record is newer than the JAMF record. Nothing to sync. If this wrong, then force an inventory update in JAMF")
                logging.debug("Not updating the Snipe asset because Snipe has a more recent timestamp: %s < %s", jamf_time, snipe_time)

            # Update/Sync the Snipe Asset Tag Number back to JAMF
            # The user arg below is set to false if it's called, so this would fail if the user called it.
            snipe_asset_tag = snipe['rows'][0]['asset_tag']
            jamf_asset_id = jamf['general']['id']
            if (jamf['general']['asset_tag'] != snipe_asset_tag) and USER_ARGS.do_not_update_jamf:
                logging.info("JAMF doesn't have the same asset tag as SNIPE so we'll update it because it should be authoritative.")
                if snipe_asset_tag:
                    if jamf_type == 'computers':
                        update_jamf_asset_tag(jamf_asset_id, snipe_asset_tag, session=JAMF_SESSION)
                        logging.info("Device is a computer, updating computer record")
                    elif jamf_type == 'mobile_devices':
                        update_jamf_mobiledevice_asset_tag(jamf_asset_id, snipe_asset_tag, session=JAMF_SESSION)
                        logging.info("Device is a mobile device, updating the mobile device record")

logging.debug('Total amount of API calls made: %s', SNIPE_API_COUNT)
